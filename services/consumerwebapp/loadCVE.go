package consumerwebapp

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"

	"consumerwebapp/types"

	"github.com/segmentio/kafka-go"
)

type LoadCVE struct {
	db     *sql.DB
	reader *kafka.Reader
}

func NewLoadCVE(db *sql.DB, reader *kafka.Reader) *LoadCVE {
	return &LoadCVE{
		db:     db,
		reader: reader,
	}
}

func (l *LoadCVE) InsertDB(jsonData []byte) (string, error) {
	parsedCVEData := GetCVEData(jsonData)
	parsedCVEID := GetCVEID(parsedCVEData)

	fmt.Println(parsedCVEID.CveID)

	// SQL query to insert or update data based on cveId in cve_metadata
	query := `
        INSERT INTO cve.CVE (id, datatype, dataversion, cve_metadata, containers)
        VALUES ($1, $2, $3, $4::jsonb, $5::jsonb)
        ON CONFLICT (id) DO UPDATE SET
            datatype = EXCLUDED.datatype,
            dataversion = EXCLUDED.dataversion,
            cve_metadata = EXCLUDED.cve_metadata,
            containers = EXCLUDED.containers
        RETURNING (xmax = 0) AS inserted;
    `

	// Execute the SQL query
	var inserted bool
	err := l.db.QueryRow(query, parsedCVEID.CveID, parsedCVEData.DataType, parsedCVEData.DataVersion, parsedCVEData.CveMetadata, parsedCVEData.Containers).Scan(&inserted)
	if err != nil {
		return "", fmt.Errorf("failed to insert or update data: %v", err)
	}

	if inserted {
		log.Printf("New row inserted for CVE ID: %s", parsedCVEID.CveID)
		return "Data inserted successfully", nil
	} else {
		log.Printf("Existing row updated for CVE ID: %s", parsedCVEID.CveID)
		return "Data updated successfully", nil
	}
}

func GetCVEData(jsonData []byte) types.CVEData {
	var cveData types.CVEData
	err := json.Unmarshal(jsonData, &cveData)
	if err != nil {
		log.Fatal(err)
	}
	return cveData
}

func GetCVEID(parsedCVEData types.CVEData) types.CveMetadataID {
	var cveId types.CveMetadataID
	err := json.Unmarshal(parsedCVEData.CveMetadata, &cveId)
	if err != nil {
		log.Fatal(err)
	}
	return cveId
}
